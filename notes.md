
## `<script>` tag placement

The placement of the `<script>` tag within an HTML document can significantly affect the behavior and performance of the web page. Here are some common placements and their implications:

1. **Inside the `<head>` section**: Placing `<script>` tags within the `<head>` section allows scripts to be loaded and executed early in the page's lifecycle. This can be beneficial for scripts that are required to run before the page content is displayed or for scripts that are essential for the page to function properly. However, it can also delay the rendering of the page content if the scripts take a long time to load or execute.

2. **At the end of the `<body>` section**: Placing `<script>` tags at the end of the `<body>` section ensures that they are loaded after the page content has been rendered. This can improve the perceived performance of the page, as users will see the content more quickly. Additionally, it prevents scripts from blocking the rendering of the page. However, scripts placed here may still delay the execution of other scripts or interact with the DOM before it's fully loaded.

3. **Using async or defer attributes**: The `async` and `defer` attributes can be added to `<script>` tags to control how scripts are loaded and executed. 
   - **`async`**: Scripts with the `async` attribute are loaded asynchronously and executed as soon as they are available, without blocking the rendering of the page. However, they may execute out of order, which can lead to unpredictable behavior.
   - **`defer`**: Scripts with the `defer` attribute are also loaded asynchronously, but they are executed in the order they appear in the document, after the document has been parsed but before the `DOMContentLoaded` event is fired. This can be useful for scripts that rely on the DOM being fully loaded.

Overall, the placement of `<script>` tags depends on the specific requirements of the page and the behavior you want to achieve. It's important to consider factors such as page load time, script dependencies, and the impact on user experience when deciding where to place scripts in an HTML document.


## `package.json` and `package-lock.json` 

1. **package.json**:
   - This file is a manifest for the project and is used to manage project metadata and dependencies.
   - It contains information such as the project name, version, description, author, and scripts.
   - One of its main purposes is to list the project's dependencies along with their version ranges. Developers typically add dependencies manually or using npm commands like `npm install package-name --save`.
   - `package.json` is meant to be committed to version control and shared with others working on the project.

2. **package-lock.json**:
   - This file is automatically generated and maintained by npm and serves as a record of the exact versions of dependencies that were installed for the project.
   - It ensures that every developer working on the project installs the exact same versions of dependencies, regardless of differences in their local environment or the order in which dependencies were installed.
   - `package-lock.json` also includes additional metadata such as the resolved URLs of package tarballs and integrity hashes for package contents.
   - It's not intended to be directly edited by developers, and npm manages it automatically when dependencies are installed or updated.

In summary, while `package.json` describes the project and its dependencies at a high level, `package-lock.json` provides a detailed, version-locked snapshot of the dependencies that ensures consistency across different development environments. Both files are crucial for managing dependencies effectively in Node.js projects.


## Caret vs Tilde

1. **Caret (`^`)**:
   - When you specify a version range with the caret (`^`), npm will allow updates to the specified dependency up to the next major version.
   - For example, if you specify `"^1.2.3"`, npm will allow updating to any version within the range `1.x.x`, but it won't update to version `2.0.0` or higher.

2. **Tilde (`~`)**:
   - When you specify a version range with the tilde (`~`), npm will allow updates to the specified dependency up to the next minor version.
   - For example, if you specify `"~1.2.3"`, npm will allow updating to any version within the range `1.2.x`, but it won't update to version `1.3.0` or higher.
  

## Browser scripts vs modules

| Aspect                 | Browser Script                                       | Module                                                |
|------------------------|------------------------------------------------------|-------------------------------------------------------|
| Scope                  | Operates within the global scope of the browser window. | Introduces encapsulation, scoped within the module.   |
| Dependency Management  | Manual, scripts need to be included in a specific order in HTML. | Supports explicit dependency declaration using `import` statements. |
| Encapsulation          | Lacks encapsulation, leading to potential conflicts between scripts. | Provides encapsulation, variables and functions are scoped within the module. |
| Execution              | Synchronously loaded and executed, potentially blocking page rendering. | Asynchronously loaded, allowing page rendering to continue while fetching modules. |
| Benefits               | Easy to get started with, suitable for small projects. | Promotes code organization, modularity, and better dependency management. |


## Bundler

A bundler is a tool used in web development to combine multiple separate files or modules into a single file (or multiple files) in a format optimized for deployment (the process is called Bundling). Bundlers are commonly used for JavaScript applications, but they can also bundle other types of assets such as CSS, images, and fonts.

The main purposes of bundlers are:

1. **Dependency Management**: Bundlers handle dependencies between different modules or files in a project. They analyze the dependency graph and ensure that modules are bundled in the correct order to satisfy dependencies.

2. **Code Transformation**: Bundlers often include tools for transforming code using preprocessors or transpilers. For example, they can convert modern JavaScript syntax (such as ES6+) into a format compatible with older browsers.

3. **Optimization**: Bundlers can optimize the bundled output by removing dead code, minifying JavaScript and CSS, and other techniques to reduce file sizes and improve loading times.

4. **Code Splitting**: Advanced bundlers support code splitting, a technique that breaks the codebase into smaller chunks and loads them dynamically as needed. This can improve the initial loading time of the application by only loading the code required for the current page or feature.

Some popular bundlers in the JavaScript ecosystem include webpack, Parcel, and Rollup. By bundling assets together, developers can simplify deployment and improve performance by reducing the number of HTTP requests needed to load a web page. Bundling also aids in managing complex codebases more efficiently, particularly in large-scale projects where there are numerous dependencies and files to manage.

### Parcel
    - Dev build (different dev and prod build)
    - Local server
    - HMR
    - File watching algorithm - written in c++
    - cache - faster build
    - image optimization
    - minification
    - bundling
    - compress
    - consistent hashing
    - code splitting
    - differntial building - to support older browser versions
    - diagnostic 
    - error handling 
    - HTTPS support 
    - Tree shaking - remove unused code

## HMR
HMR stands for Hot Module Replacement. It's a feature commonly used in development environments, especially in web development with frameworks like React, Vue.js, and webpack.

HMR allows developers to make changes to their code (such as JavaScript, CSS, or even HTML) while the application is running, and see those changes instantly reflected in the browser without needing to refresh the page. 

Here's how it typically works:

1. **Detection of Changes**: The development server monitors the project files for changes. When a change is detected, the server initiates the HMR process.

2. **Replacement of Modules**: Instead of reloading the entire application, HMR only updates the modules that have changed. It swaps out the old version of the module with the new one, preserving the application's state as much as possible.

3. **Application Update**: Once the modules are replaced, the application re-renders with the updated code. Any changes made by the developer become immediately visible in the browser, providing a faster feedback loop during development.

HMR significantly speeds up the development process by eliminating the need for manual page refreshes after making code changes. It helps developers maintain their focus and productivity by reducing the turnaround time for seeing the effects of their modifications.


## Consistent hashing
Consistent hashing is a hashing technique used in distributed systems to efficiently distribute and manage data across multiple nodes or servers while minimizing the impact of adding or removing nodes.

In traditional hashing, data is distributed among a fixed number of buckets based on the hash value of the data. However, when nodes are added or removed from the system, a significant portion of the data may need to be rehashed and redistributed, which can be computationally expensive and lead to a lot of data movement.

Consistent hashing addresses this issue by introducing the concept of virtual nodes and a ring-based hash space. Here's how it works:

1. **Hash Space**: Consistent hashing uses a hash function to map keys or data to a continuous hash space, typically represented as a ring.

2. **Virtual Nodes**: Each physical node in the system is associated with multiple virtual nodes distributed evenly around the hash ring. The more virtual nodes a physical node has, the more evenly distributed the data will be.

3. **Data Mapping**: When data needs to be stored or retrieved, it is hashed to determine its position on the hash ring. The data is then assigned to the nearest virtual node in a clockwise direction on the ring.

4. **Node Addition or Removal**: When a node is added or removed from the system, only a fraction of the data needs to be remapped. Since each node is responsible for a range of keys, adding or removing a node affects only the keys that fall within the range of that node.

5. **Load Balancing**: Consistent hashing helps distribute the data load evenly across nodes, as each node is responsible for approximately the same number of keys. This leads to better load balancing and reduces the likelihood of hotspots where a single node becomes overloaded with requests.

Consistent hashing is widely used in distributed systems, such as distributed databases, content delivery networks (CDNs), and distributed caching systems, to provide scalability, fault tolerance, and efficient data distribution across multiple nodes.

## Differential bundling
"Differential bundling" is a concept related to optimizing the delivery of web assets, such as JavaScript bundles, based on the capabilities of the requesting client or browser.

Traditionally, web applications deliver the same bundle of assets to all users, regardless of their browser capabilities. However, this approach can be inefficient because modern browsers may support newer JavaScript features or have better performance characteristics than older browsers. Delivering a single, monolithic bundle to all users may result in unnecessary overhead for users with more capable browsers.

Differential bundling addresses this issue by generating and delivering different versions of asset bundles based on the capabilities of the requesting client. For example:

1. **Modern Bundle**: This bundle contains the latest JavaScript features and optimizations tailored for modern browsers that support them.

2. **Legacy Bundle**: This bundle is designed for older browsers that may not support certain modern JavaScript features or have performance limitations. It may include transpiled code, polyfills, or other optimizations to ensure compatibility with older browsers.

When a user visits a website, the server detects the capabilities of the user's browser (e.g., through user-agent sniffing or feature detection) and serves the appropriate bundle accordingly.

Differential bundling offers several benefits:

- **Improved Performance**: Users with modern browsers receive optimized bundles that leverage the latest features and performance enhancements, resulting in faster load times and better user experiences.
  
- **Reduced Payload**: Users with older browsers receive bundles tailored to their capabilities, reducing the amount of unnecessary code and improving load times on slower devices or networks.

- **Simplified Maintenance**: Developers can write code using modern JavaScript features without worrying about compatibility issues, as the bundling process automatically generates compatible bundles for older browsers.

Overall, differential bundling is a technique that helps optimize the delivery of web assets by tailoring bundles to the capabilities of the requesting client, resulting in improved performance and user experiences.

## Why the app is fast

React plays a significant role in creating efficient and performant web applications, but the bundlers also contribute significantly to the overall speed and efficiency of the application.

Bundlers like webpack, Parcel, and Rollup optimize the delivery of assets by bundling, minifying, and compressing files, reducing the number of HTTP requests and the overall size of the resources sent to the client. This optimization leads to faster load times, quicker rendering, and a smoother user experience.

Additionally, bundlers often include features like code splitting, tree shaking, and caching, which further enhance performance by loading only the necessary code, eliminating dead code, and caching assets for faster subsequent visits.

Furthermore, bundlers can handle tasks such as CSS preprocessing, image optimization, and asset management, streamlining the development process and allowing developers to focus on writing code rather than managing dependencies and build configurations.

In summary, bundlers are indeed crucial in optimizing web applications for speed and efficiency, working hand in hand with libraries like React to deliver fast and responsive user experiences.




## JSX
   - JSX stands for JavaScript XML. It's a syntax extension that allows developers to write HTML-like code directly within JavaScript. JSX makes it easier to create and compose user interfaces in React by providing a more familiar syntax for defining components and their structure.
   - JSX syntax resembles HTML, but it's ultimately transpiled into regular JavaScript function calls. For example, a JSX expression like `<div>Hello, world!</div>` is transformed into `React.createElement('div', null, 'Hello, world!')` behind the scenes.
   - JSX allows developers to write more declarative and readable code, as it closely resembles the structure of the UI being rendered. It also enables the embedding of JavaScript expressions and logic directly within the markup, facilitating dynamic rendering and data manipulation.

## Babel
   - Babel is a popular JavaScript compiler that transforms modern JavaScript code (including JSX) into a backwards-compatible version that can be executed in older browsers or environments that don't support the latest language features.
   - Babel is highly configurable and supports various plugins and presets that allow developers to customize the transformation process according to their specific needs. For example, the `@babel/preset-react` preset is commonly used to enable JSX transformation.
   - Babel can be integrated into the build process of a project using tools like webpack, Parcel, or npm scripts. It's often used alongside other tools like webpack to bundle and optimize JavaScript code for production deployment.
   - In the context of React development, Babel is typically used to compile JSX syntax into regular JavaScript, allowing developers to write React components using JSX without worrying about browser compatibility issues.

